
nios2_DigitalLock.elf:     file format elf32-littlenios2
nios2_DigitalLock.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002020

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00002020 paddr 0x00002020 align 2**12
         filesz 0x00000874 memsz 0x00000874 flags r-x
    LOAD off    0x00001894 vaddr 0x00002894 paddr 0x0000289c align 2**12
         filesz 0x00000008 memsz 0x00000008 flags rw-
    LOAD off    0x000018a4 vaddr 0x000028a4 paddr 0x000028a4 align 2**12
         filesz 0x00000000 memsz 0x00000010 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         00000864  00002020  00002020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000010  00002884  00002884  00001884  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rwdata       00000008  00002894  0000289c  00001894  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  4 .bss          00000010  000028a4  000028a4  000018a4  2**2
                  ALLOC, SMALL_DATA
  5 .comment      00000026  00000000  00000000  0000189c  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 000001c8  00000000  00000000  000018c8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000022c  00000000  00000000  00001a90  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00001121  00000000  00000000  00001cbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000088d  00000000  00000000  00002ddd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001e06  00000000  00000000  0000366a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000300  00000000  00000000  00005470  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000081a  00000000  00000000  00005770  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00000628  00000000  00000000  00005f8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000040  00000000  00000000  000065b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000000a0  00000000  00000000  000065f8  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000003  00000000  00000000  0000767d  2**0
                  CONTENTS, READONLY
 17 .cpu          00000003  00000000  00000000  00007680  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  00007683  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  00007684  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  00007685  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  00007689  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  0000768d  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  00007691  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0000769a  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  000076a3  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 0000000b  00000000  00000000  000076ac  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001f  00000000  00000000  000076b7  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     0004bd0d  00000000  00000000  000076d6  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00002020 l    d  .text	00000000 .text
00002884 l    d  .rodata	00000000 .rodata
00002894 l    d  .rwdata	00000000 .rwdata
000028a4 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00002058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
0000205c l     F .text	00000058 pack4
00002884 l     O .rodata	00000010 seg7
000020b4 l     F .text	00000024 press_event
000020d8 l     F .text	00000010 read_key
000020e8 l     F .text	00000044 wait_release
0000212c l     F .text	0000000c hex_write
00002138 l     F .text	00000030 show_entry
00002168 l     F .text	00000040 clear_entry
000021a8 l     F .text	00000018 leds_err
000021c0 l     F .text	00000018 leds_ok
000021d8 l     F .text	00000014 leds_off
00002894 l     O .rwdata	00000004 C.6.1801
000028a4 l     O .bss	00000001 blink_state.1793
00000000 l    df *ABS*	00000000 lib2-divmod.c
00002538 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_load.c
000026d0 l     F .text	00000020 alt_load_section
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 lib2-mul.c
0000275c g     F .text	0000002c alt_main
0000289c g       *ABS*	00000000 __flash_rwdata_start
00002000 g     F .entry	0000000c __reset
00002020 g       *ABS*	00000000 __flash_exceptions_start
000028ac g     O .bss	00000004 alt_argv
0000a894 g       *ABS*	00000000 _gp
00002788 g     F .text	00000004 usleep
00002684 g     F .text	0000002c memcpy
00002674 g     F .text	00000008 __udivsi3
000028b4 g       *ABS*	00000000 __bss_end
0000283c g     F .text	00000004 alt_dcache_flush_all
0000289c g       *ABS*	00000000 __ram_rwdata_end
00002898 g     O .rwdata	00000004 JTAG_UART
00002894 g       *ABS*	00000000 __ram_rodata_end
0000267c g     F .text	00000008 __umodsi3
000028b4 g       *ABS*	00000000 end
00004000 g       *ABS*	00000000 __alt_stack_pointer
00002020 g     F .text	0000003c _start
0000278c g     F .text	00000004 alt_sys_init
0000284c g     F .text	00000038 __mulsi3
00002894 g       *ABS*	00000000 __ram_rwdata_start
00002884 g       *ABS*	00000000 __ram_rodata_start
000027b0 g     F .text	0000008c alt_busy_sleep
000028b4 g       *ABS*	00000000 __alt_stack_base
000028a4 g       *ABS*	00000000 __bss_start
000026b0 g     F .text	00000020 memset
000021ec g     F .text	0000034c main
000028b0 g     O .bss	00000004 alt_envp
000025b4 g     F .text	00000060 __divsi3
00002884 g       *ABS*	00000000 __flash_rodata_start
00002790 g     F .text	00000020 alt_irq_init
00002000 g       *ABS*	00000000 __alt_mem_IN_RAM
000028a8 g     O .bss	00000004 alt_argc
00002020 g       *ABS*	00000000 __ram_exceptions_start
0000289c g       *ABS*	00000000 _edata
000028b4 g       *ABS*	00000000 _end
00002020 g       *ABS*	00000000 __ram_exceptions_end
00002844 g     F .text	00000008 altera_nios2_qsys_irq_init
0000200c g       .entry	00000000 exit
00002614 g     F .text	00000060 __modsi3
00004000 g       *ABS*	00000000 __alt_data_end
0000200c g       .entry	00000000 _exit
00002840 g     F .text	00000004 alt_icache_flush_all
000026f0 g     F .text	0000006c alt_load



Disassembly of section .entry:

00002000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2004:	08480814 	ori	at,at,8224
    jmp r1
    2008:	0800683a 	jmp	at

0000200c <_exit>:
	...

Disassembly of section .text:

00002020 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2020:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    2024:	ded00014 	ori	sp,sp,16384

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
    2028:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    202c:	d6aa2514 	ori	gp,gp,43156
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    2030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    2034:	108a2914 	ori	r2,r2,10404

    movhi r3, %hi(__bss_end)
    2038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    203c:	18ca2d14 	ori	r3,r3,10420

    beq r2, r3, 1f
    2040:	10c00326 	beq	r2,r3,2050 <_start+0x30>

0:
    stw zero, (r2)
    2044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    2048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    204c:	10fffd36 	bltu	r2,r3,2044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    2050:	00026f00 	call	26f0 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    2054:	000275c0 	call	275c <alt_main>

00002058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    2058:	003fff06 	br	2058 <alt_after_alt_main>

0000205c <pack4>:
}
static inline void hex_write(uint32_t v) {
  IOWR(HEX_BASE, 0, v);
}

static uint32_t pack4(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) {
    205c:	008003c4 	movi	r2,15
    2060:	00c00034 	movhi	r3,0
    2064:	18ca2104 	addi	r3,r3,10372
    2068:	288a703a 	and	r5,r5,r2
    206c:	28cb883a 	add	r5,r5,r3
    2070:	308c703a 	and	r6,r6,r2
    2074:	2a000003 	ldbu	r8,0(r5)
    2078:	30cd883a 	add	r6,r6,r3
    207c:	388e703a 	and	r7,r7,r2
    2080:	38cf883a 	add	r7,r7,r3
    2084:	2088703a 	and	r4,r4,r2
    2088:	31400003 	ldbu	r5,0(r6)
    208c:	20c9883a 	add	r4,r4,r3
    2090:	38c00003 	ldbu	r3,0(r7)
    2094:	20800003 	ldbu	r2,0(r4)
    2098:	401091fa 	slli	r8,r8,7
    209c:	280a93ba 	slli	r5,r5,14
    20a0:	1806957a 	slli	r3,r3,21
    20a4:	1204b03a 	or	r2,r2,r8
    20a8:	1144b03a 	or	r2,r2,r5
  uint32_t h0 = seg7[d0 & 0xF];
  uint32_t h1 = seg7[d1 & 0xF];
  uint32_t h2 = seg7[d2 & 0xF];
  uint32_t h3 = seg7[d3 & 0xF];
  return (h0) | (h1 << 7) | (h2 << 14) | (h3 << 21);
}
    20ac:	10c4b03a 	or	r2,r2,r3
    20b0:	f800283a 	ret

000020b4 <press_event>:
  }
  usleep(AFTER_RELEASE_US);
}

static int press_event(uint32_t prev, uint32_t now, int bit) {
  int was_released = ((prev & (1u << bit)) != 0);
    20b4:	00800044 	movi	r2,1
    20b8:	1184983a 	sll	r2,r2,r6
  int now_pressed  = ((now  & (1u << bit)) == 0);
  return (was_released && now_pressed);
    20bc:	0007883a 	mov	r3,zero
    20c0:	2088703a 	and	r4,r4,r2
    20c4:	288a703a 	and	r5,r5,r2
    20c8:	20000126 	beq	r4,zero,20d0 <press_event+0x1c>
    20cc:	2807003a 	cmpeq	r3,r5,zero
}
    20d0:	1805883a 	mov	r2,r3
    20d4:	f800283a 	ret

000020d8 <read_key>:
  0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78,
  0x00, 0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0E
};

// ---------- HW ACCESS ----------
static inline uint32_t read_key(void) { return IORD(KEY_BASE, 0) & 0xF; }
    20d8:	00940c04 	movi	r2,20528
    20dc:	10800037 	ldwio	r2,0(r2)
    20e0:	108003cc 	andi	r2,r2,15
    20e4:	f800283a 	ret

000020e8 <wait_release>:
// ---------- DEBOUNCE ----------
static inline int is_pressed(uint32_t k, int bit) {
  return ((k & (1u << bit)) == 0);
}

static void wait_release(int bit) {
    20e8:	defffe04 	addi	sp,sp,-8
    20ec:	dc000015 	stw	r16,0(sp)
    20f0:	2021883a 	mov	r16,r4
    20f4:	dfc00115 	stw	ra,4(sp)
    20f8:	00000106 	br	2100 <wait_release+0x18>
  while (is_pressed(read_key(), bit)) {
    usleep(POLL_US);
    20fc:	00027880 	call	2788 <usleep>
static inline int is_pressed(uint32_t k, int bit) {
  return ((k & (1u << bit)) == 0);
}

static void wait_release(int bit) {
  while (is_pressed(read_key(), bit)) {
    2100:	00020d80 	call	20d8 <read_key>
    2104:	00c00044 	movi	r3,1
    2108:	1c06983a 	sll	r3,r3,r16
    usleep(POLL_US);
    210c:	0104e204 	movi	r4,5000
static inline int is_pressed(uint32_t k, int bit) {
  return ((k & (1u << bit)) == 0);
}

static void wait_release(int bit) {
  while (is_pressed(read_key(), bit)) {
    2110:	10c4703a 	and	r2,r2,r3
    2114:	103ff926 	beq	r2,zero,20fc <wait_release+0x14>
    usleep(POLL_US);
  }
  usleep(AFTER_RELEASE_US);
    2118:	01138804 	movi	r4,20000
}
    211c:	dfc00117 	ldw	ra,4(sp)
    2120:	dc000017 	ldw	r16,0(sp)
    2124:	dec00204 	addi	sp,sp,8

static void wait_release(int bit) {
  while (is_pressed(read_key(), bit)) {
    usleep(POLL_US);
  }
  usleep(AFTER_RELEASE_US);
    2128:	00027881 	jmpi	2788 <usleep>

0000212c <hex_write>:
static inline void leds_err(void) {
  IOWR(LEDG_BASE, 0, 0);
  IOWR(LEDR_BASE, 0, 1);
}
static inline void hex_write(uint32_t v) {
  IOWR(HEX_BASE, 0, v);
    212c:	00941804 	movi	r2,20576
    2130:	11000035 	stwio	r4,0(r2)
}
    2134:	f800283a 	ret

00002138 <show_entry>:
  for (i = 0; i < CODE_LEN; i++) entry[i] = 0;
  *idx = 0;
  hex_write(pack4(0,0,0,0));
}

static void show_entry(const uint8_t entry[CODE_LEN]) {
    2138:	deffff04 	addi	sp,sp,-4
    213c:	dfc00015 	stw	ra,0(sp)
    2140:	2005883a 	mov	r2,r4
  hex_write(pack4(entry[0], entry[1], entry[2], entry[3]));
    2144:	21c000c3 	ldbu	r7,3(r4)
    2148:	11400043 	ldbu	r5,1(r2)
    214c:	21000003 	ldbu	r4,0(r4)
    2150:	11800083 	ldbu	r6,2(r2)
    2154:	000205c0 	call	205c <pack4>
    2158:	1009883a 	mov	r4,r2
}
    215c:	dfc00017 	ldw	ra,0(sp)
    2160:	dec00104 	addi	sp,sp,4
  *idx = 0;
  hex_write(pack4(0,0,0,0));
}

static void show_entry(const uint8_t entry[CODE_LEN]) {
  hex_write(pack4(entry[0], entry[1], entry[2], entry[3]));
    2164:	000212c1 	jmpi	212c <hex_write>

00002168 <clear_entry>:
  int now_pressed  = ((now  & (1u << bit)) == 0);
  return (was_released && now_pressed);
}

// ---------- HELPERS ----------
static void clear_entry(uint8_t entry[CODE_LEN], uint8_t *idx) {
    2168:	deffff04 	addi	sp,sp,-4
    216c:	dfc00015 	stw	ra,0(sp)
  int i;
  for (i = 0; i < CODE_LEN; i++) entry[i] = 0;
    2170:	200000c5 	stb	zero,3(r4)
    2174:	20000005 	stb	zero,0(r4)
    2178:	20000045 	stb	zero,1(r4)
    217c:	20000085 	stb	zero,2(r4)
  *idx = 0;
    2180:	28000005 	stb	zero,0(r5)
  hex_write(pack4(0,0,0,0));
    2184:	0009883a 	mov	r4,zero
    2188:	000b883a 	mov	r5,zero
    218c:	000d883a 	mov	r6,zero
    2190:	000f883a 	mov	r7,zero
    2194:	000205c0 	call	205c <pack4>
    2198:	1009883a 	mov	r4,r2
}
    219c:	dfc00017 	ldw	ra,0(sp)
    21a0:	dec00104 	addi	sp,sp,4
// ---------- HELPERS ----------
static void clear_entry(uint8_t entry[CODE_LEN], uint8_t *idx) {
  int i;
  for (i = 0; i < CODE_LEN; i++) entry[i] = 0;
  *idx = 0;
  hex_write(pack4(0,0,0,0));
    21a4:	000212c1 	jmpi	212c <hex_write>

000021a8 <leds_err>:
static inline void leds_ok(void) {
  IOWR(LEDR_BASE, 0, 0);
  IOWR(LEDG_BASE, 0, 1);
}
static inline void leds_err(void) {
  IOWR(LEDG_BASE, 0, 0);
    21a8:	00941404 	movi	r2,20560
    21ac:	10000035 	stwio	zero,0(r2)
  IOWR(LEDR_BASE, 0, 1);
    21b0:	00c00044 	movi	r3,1
    21b4:	00941004 	movi	r2,20544
    21b8:	10c00035 	stwio	r3,0(r2)
}
    21bc:	f800283a 	ret

000021c0 <leds_ok>:
static inline void leds_off(void) {
  IOWR(LEDR_BASE, 0, 0);
  IOWR(LEDG_BASE, 0, 0);
}
static inline void leds_ok(void) {
  IOWR(LEDR_BASE, 0, 0);
    21c0:	00941004 	movi	r2,20544
    21c4:	10000035 	stwio	zero,0(r2)
  IOWR(LEDG_BASE, 0, 1);
    21c8:	00c00044 	movi	r3,1
    21cc:	00941404 	movi	r2,20560
    21d0:	10c00035 	stwio	r3,0(r2)
}
    21d4:	f800283a 	ret

000021d8 <leds_off>:
// ---------- HW ACCESS ----------
static inline uint32_t read_key(void) { return IORD(KEY_BASE, 0) & 0xF; }
static inline uint32_t read_sw(void)  { return IORD(SW_BASE,  0) & 0x3FF; }

static inline void leds_off(void) {
  IOWR(LEDR_BASE, 0, 0);
    21d8:	00941004 	movi	r2,20544
    21dc:	10000035 	stwio	zero,0(r2)
  IOWR(LEDG_BASE, 0, 0);
    21e0:	00941404 	movi	r2,20560
    21e4:	10000035 	stwio	zero,0(r2)
}
    21e8:	f800283a 	ret

000021ec <main>:
  }
  return 1; // Lockout completed
}

// ---------- MAIN ----------
int main(void) {
    21ec:	defff604 	addi	sp,sp,-40
  uint8_t code[CODE_LEN]  = {1,2,3,4};  // Default password
    21f0:	d9000144 	addi	r4,sp,5
    21f4:	d1600004 	addi	r5,gp,-32768
    21f8:	01800104 	movi	r6,4
  }
  return 1; // Lockout completed
}

// ---------- MAIN ----------
int main(void) {
    21fc:	dfc00915 	stw	ra,36(sp)
    2200:	dd400815 	stw	r21,32(sp)
    2204:	dcc00615 	stw	r19,24(sp)
    2208:	dc800515 	stw	r18,20(sp)
    220c:	dc400415 	stw	r17,16(sp)
    2210:	dd000715 	stw	r20,28(sp)
    2214:	dc000315 	stw	r16,12(sp)
  uint8_t code[CODE_LEN]  = {1,2,3,4};  // Default password
    2218:	00026840 	call	2684 <memcpy>
  uint8_t entry[CODE_LEN] = {0,0,0,0};
    221c:	d9000044 	addi	r4,sp,1
    2220:	000b883a 	mov	r5,zero
    2224:	01800104 	movi	r6,4
    2228:	00026b00 	call	26b0 <memset>
  uint8_t idx = 0;
    222c:	d8000005 	stb	zero,0(sp)
  uint8_t wrong_streak = 0;
  state_t state = STATE_IDLE;
  uint16_t blink_counter = 0;

  leds_off();
    2230:	00021d80 	call	21d8 <leds_off>
  hex_write(pack4(0,0,0,0));
    2234:	000b883a 	mov	r5,zero
    2238:	000d883a 	mov	r6,zero
    223c:	000f883a 	mov	r7,zero
    2240:	0009883a 	mov	r4,zero
    2244:	000205c0 	call	205c <pack4>
    2248:	1009883a 	mov	r4,r2
    224c:	000212c0 	call	212c <hex_write>

  uint32_t prev_k = read_key();
    2250:	00020d80 	call	20d8 <read_key>
    2254:	1023883a 	mov	r17,r2
    2258:	002b883a 	mov	r21,zero
    225c:	0027883a 	mov	r19,zero
    2260:	0025883a 	mov	r18,zero
    2264:	00000306 	br	2274 <main+0x88>
        }
      }
    }

    prev_k = k;
    usleep(POLL_US);
    2268:	0104e204 	movi	r4,5000
    226c:	00027880 	call	2788 <usleep>
  uint16_t blink_counter = 0;

  leds_off();
  hex_write(pack4(0,0,0,0));

  uint32_t prev_k = read_key();
    2270:	a023883a 	mov	r17,r20

  while (1) {
    uint32_t k = read_key();
    2274:	00020d80 	call	20d8 <read_key>
    2278:	1029883a 	mov	r20,r2

    // ---------- HANDLE CHANGE MODE BLINKING ----------
    if (state == STATE_CHANGE_MODE) {
    227c:	00800084 	movi	r2,2
    2280:	9880101e 	bne	r19,r2,22c4 <main+0xd8>
      blink_counter++;
    2284:	94800044 	addi	r18,r18,1
      if (blink_counter >= BLINK_CYCLES) {
    2288:	90ffffcc 	andi	r3,r18,65535
    228c:	008018c4 	movi	r2,99
    2290:	10c00c2e 	bgeu	r2,r3,22c4 <main+0xd8>
        blink_counter = 0;
        // Toggle display: show entry or blank
        static uint8_t blink_state = 0;
        blink_state = !blink_state;
    2294:	d0e00403 	ldbu	r3,-32752(gp)
    2298:	1807003a 	cmpeq	r3,r3,zero
        if (blink_state) {
    229c:	1805003a 	cmpeq	r2,r3,zero
      blink_counter++;
      if (blink_counter >= BLINK_CYCLES) {
        blink_counter = 0;
        // Toggle display: show entry or blank
        static uint8_t blink_state = 0;
        blink_state = !blink_state;
    22a0:	d0e00405 	stb	r3,-32752(gp)
        if (blink_state) {
    22a4:	1000031e 	bne	r2,zero,22b4 <main+0xc8>
          show_entry(entry);
    22a8:	d9000044 	addi	r4,sp,1
    22ac:	00021380 	call	2138 <show_entry>
    22b0:	00000306 	br	22c0 <main+0xd4>
        } else {
          hex_write(0x7F7F7F7F); // All segments off (blank)
    22b4:	011fdff4 	movhi	r4,32639
    22b8:	211fdfc4 	addi	r4,r4,32639
    22bc:	000212c0 	call	212c <hex_write>
    22c0:	0025883a 	mov	r18,zero
        }
      }
    }

    // ---------- KEY2: RESET (works in any state) ----------
    if (press_event(prev_k, k, 2)) {
    22c4:	8809883a 	mov	r4,r17
    22c8:	a00b883a 	mov	r5,r20
    22cc:	01800084 	movi	r6,2
    22d0:	00020b40 	call	20b4 <press_event>
    22d4:	10000a26 	beq	r2,zero,2300 <main+0x114>
      wait_release(2);
    22d8:	01000084 	movi	r4,2
    22dc:	00020e80 	call	20e8 <wait_release>

      state = STATE_IDLE;
      wrong_streak = 0;
      clear_entry(entry, &idx);
    22e0:	d80b883a 	mov	r5,sp
    22e4:	d9000044 	addi	r4,sp,1
    22e8:	00021680 	call	2168 <clear_entry>
      leds_off();
    22ec:	002b883a 	mov	r21,zero
    22f0:	00021d80 	call	21d8 <leds_off>
    22f4:	0027883a 	mov	r19,zero
    22f8:	0025883a 	mov	r18,zero
    22fc:	00000206 	br	2308 <main+0x11c>
      blink_counter = 0;
    }

    // ---------- LOCKED STATE: Only countdown, ignore other keys ----------
    if (state == STATE_LOCKED) {
    2300:	008000c4 	movi	r2,3
    2304:	98bfd826 	beq	r19,r2,2268 <main+0x7c>
      usleep(POLL_US);
      continue;
    }

    // ---------- KEY3: ENTER CHANGE MODE ----------
    if (press_event(prev_k, k, 3)) {
    2308:	040000c4 	movi	r16,3
    230c:	8809883a 	mov	r4,r17
    2310:	a00b883a 	mov	r5,r20
    2314:	800d883a 	mov	r6,r16
    2318:	00020b40 	call	20b4 <press_event>
    231c:	10000926 	beq	r2,zero,2344 <main+0x158>
      wait_release(3);
    2320:	8009883a 	mov	r4,r16
    2324:	00020e80 	call	20e8 <wait_release>

      state = STATE_CHANGE_MODE;
      wrong_streak = 0;
      clear_entry(entry, &idx);
    2328:	d80b883a 	mov	r5,sp
    232c:	d9000044 	addi	r4,sp,1
    2330:	00021680 	call	2168 <clear_entry>
      leds_off();
    2334:	002b883a 	mov	r21,zero
    2338:	00021d80 	call	21d8 <leds_off>
    233c:	04c00084 	movi	r19,2
    2340:	0025883a 	mov	r18,zero
      blink_counter = 0;
    }

    // ---------- KEY0: ENTER DIGIT ----------
    if (press_event(prev_k, k, 0)) {
    2344:	8809883a 	mov	r4,r17
    2348:	a00b883a 	mov	r5,r20
    234c:	000d883a 	mov	r6,zero
    2350:	00020b40 	call	20b4 <press_event>
    2354:	10001626 	beq	r2,zero,23b0 <main+0x1c4>
      wait_release(0);
    2358:	0009883a 	mov	r4,zero
    235c:	00020e80 	call	20e8 <wait_release>
  0x00, 0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0E
};

// ---------- HW ACCESS ----------
static inline uint32_t read_key(void) { return IORD(KEY_BASE, 0) & 0xF; }
static inline uint32_t read_sw(void)  { return IORD(SW_BASE,  0) & 0x3FF; }
    2360:	00940804 	movi	r2,20512
    2364:	10800037 	ldwio	r2,0(r2)
      wait_release(0);

      uint8_t digit = (uint8_t)(read_sw() & 0xF);
      if (digit > 9) digit = 9;

      if (idx < CODE_LEN) {
    2368:	d9c00003 	ldbu	r7,0(sp)
    236c:	39403fcc 	andi	r5,r7,255
    2370:	81400f36 	bltu	r16,r5,23b0 <main+0x1c4>
        entry[idx] = digit;
    2374:	10c003cc 	andi	r3,r2,15
    2378:	d9000044 	addi	r4,sp,1
    237c:	18803fcc 	andi	r2,r3,255
    2380:	01800244 	movi	r6,9
    2384:	214b883a 	add	r5,r4,r5
    2388:	3080012e 	bgeu	r6,r2,2390 <main+0x1a4>
    238c:	3007883a 	mov	r3,r6
        idx++;
    2390:	38800044 	addi	r2,r7,1

      uint8_t digit = (uint8_t)(read_sw() & 0xF);
      if (digit > 9) digit = 9;

      if (idx < CODE_LEN) {
        entry[idx] = digit;
    2394:	28c00005 	stb	r3,0(r5)
        idx++;
    2398:	d8800005 	stb	r2,0(sp)
        show_entry(entry);
    239c:	00021380 	call	2138 <show_entry>
        leds_off();
    23a0:	00021d80 	call	21d8 <leds_off>

        // Update state
        if (state == STATE_IDLE) {
    23a4:	9800011e 	bne	r19,zero,23ac <main+0x1c0>
    23a8:	04c00044 	movi	r19,1
    23ac:	0025883a 	mov	r18,zero
        blink_counter = 0; // Reset blink if in change mode
      }
    }

    // ---------- KEY1: VERIFY OR SAVE ----------
    if (press_event(prev_k, k, 1)) {
    23b0:	8809883a 	mov	r4,r17
    23b4:	a00b883a 	mov	r5,r20
    23b8:	01800044 	movi	r6,1
    23bc:	00020b40 	call	20b4 <press_event>
    23c0:	103fa926 	beq	r2,zero,2268 <main+0x7c>
      wait_release(1);
    23c4:	01000044 	movi	r4,1
    23c8:	00020e80 	call	20e8 <wait_release>

      // Require full 4 digits
      if (idx < CODE_LEN) {
    23cc:	d8c00003 	ldbu	r3,0(sp)
    23d0:	008000c4 	movi	r2,3
    23d4:	10c00636 	bltu	r2,r3,23f0 <main+0x204>
        // Not enough digits - blink error briefly
        leds_err();
    23d8:	00021a80 	call	21a8 <leds_err>
        usleep(200000); // 200ms error indication
    23dc:	010000f4 	movhi	r4,3
    23e0:	21035004 	addi	r4,r4,3392
    23e4:	00027880 	call	2788 <usleep>
        leds_off();
    23e8:	00021d80 	call	21d8 <leds_off>
    23ec:	003f9e06 	br	2268 <main+0x7c>
        prev_k = k;
        usleep(POLL_US);
        continue;
      }

      if (state == STATE_CHANGE_MODE) {
    23f0:	00800084 	movi	r2,2
    23f4:	9880091e 	bne	r19,r2,241c <main+0x230>
        // SAVE NEW PASSWORD
    	int i;
        for ( i = 0; i < CODE_LEN; i++) {
          code[i] = entry[i];
    23f8:	d8800043 	ldbu	r2,1(sp)
    23fc:	d8800145 	stb	r2,5(sp)
    2400:	d8800083 	ldbu	r2,2(sp)
    2404:	d8800185 	stb	r2,6(sp)
    2408:	d88000c3 	ldbu	r2,3(sp)
    240c:	d88001c5 	stb	r2,7(sp)
    2410:	d8800103 	ldbu	r2,4(sp)
    2414:	d8800205 	stb	r2,8(sp)
    2418:	00004206 	br	2524 <main+0x338>
        }
        state = STATE_IDLE;
        wrong_streak = 0;
        leds_ok();
        clear_entry(entry, &idx);
    241c:	000b883a 	mov	r5,zero
    2420:	dc000044 	addi	r16,sp,1
    2424:	d9c00144 	addi	r7,sp,5
    2428:	01800104 	movi	r6,4
}

static int codes_match(const uint8_t a[CODE_LEN], const uint8_t b[CODE_LEN]) {
  int i;
  for (i = 0; i < CODE_LEN; i++) {
    if (a[i] != b[i]) return 0;
    242c:	8145883a 	add	r2,r16,r5
    2430:	3947883a 	add	r3,r7,r5
    2434:	11000003 	ldbu	r4,0(r2)
    2438:	18800003 	ldbu	r2,0(r3)
  hex_write(pack4(entry[0], entry[1], entry[2], entry[3]));
}

static int codes_match(const uint8_t a[CODE_LEN], const uint8_t b[CODE_LEN]) {
  int i;
  for (i = 0; i < CODE_LEN; i++) {
    243c:	29400044 	addi	r5,r5,1
    if (a[i] != b[i]) return 0;
    2440:	2080021e 	bne	r4,r2,244c <main+0x260>
  hex_write(pack4(entry[0], entry[1], entry[2], entry[3]));
}

static int codes_match(const uint8_t a[CODE_LEN], const uint8_t b[CODE_LEN]) {
  int i;
  for (i = 0; i < CODE_LEN; i++) {
    2444:	29803726 	beq	r5,r6,2524 <main+0x338>
    2448:	003ff806 	br	242c <main+0x240>
          leds_ok();
          clear_entry(entry, &idx);

        } else {
          wrong_streak++;
          leds_err();
    244c:	00021a80 	call	21a8 <leds_err>
          clear_entry(entry, &idx);
    2450:	8009883a 	mov	r4,r16
    2454:	d80b883a 	mov	r5,sp
    2458:	00021680 	call	2168 <clear_entry>
          state = STATE_IDLE;
          leds_ok();
          clear_entry(entry, &idx);

        } else {
          wrong_streak++;
    245c:	ad400044 	addi	r21,r21,1
          leds_err();
          clear_entry(entry, &idx);
          state = STATE_IDLE;

          if (wrong_streak >= 3) {
    2460:	a8c03fcc 	andi	r3,r21,255
    2464:	00800084 	movi	r2,2
    2468:	10c00436 	bltu	r2,r3,247c <main+0x290>
    246c:	00002b06 	br	251c <main+0x330>
    // Check KEY2 during each second
    int slice;
    for ( slice = 0; slice < 200; slice++) {
      uint32_t k = read_key();
      if (is_pressed(k, 2)) {
        wait_release(2);
    2470:	01000084 	movi	r4,2
    2474:	00020e80 	call	20e8 <wait_release>
    2478:	00001f06 	br	24f8 <main+0x30c>
          state = STATE_IDLE;

          if (wrong_streak >= 3) {
            // TRIGGER LOCKOUT
            state = STATE_LOCKED;
            leds_off();
    247c:	00021d80 	call	21d8 <leds_off>
    2480:	04400284 	movi	r17,10
static int handle_lockout(void) {
  int t;
  for (t = LOCKOUT_SECONDS; t >= 0; t--) {
    int tens = (t / 10) % 10;
    int ones = t % 10;
    hex_write(pack4(0, 0, (uint8_t)tens, (uint8_t)ones));
    2484:	01400284 	movi	r5,10
    2488:	8809883a 	mov	r4,r17
    248c:	00025b40 	call	25b4 <__divsi3>
    2490:	1009883a 	mov	r4,r2
    2494:	01400284 	movi	r5,10
    2498:	00026140 	call	2614 <__modsi3>
    249c:	8809883a 	mov	r4,r17
    24a0:	01400284 	movi	r5,10
    24a4:	14003fcc 	andi	r16,r2,255
    24a8:	00026140 	call	2614 <__modsi3>
    24ac:	800d883a 	mov	r6,r16
    24b0:	11c03fcc 	andi	r7,r2,255
    24b4:	000b883a 	mov	r5,zero
    24b8:	0009883a 	mov	r4,zero
    24bc:	000205c0 	call	205c <pack4>
    24c0:	1009883a 	mov	r4,r2
    24c4:	000212c0 	call	212c <hex_write>
    24c8:	0021883a 	mov	r16,zero

    // Check KEY2 during each second
    int slice;
    for ( slice = 0; slice < 200; slice++) {
      uint32_t k = read_key();
    24cc:	00020d80 	call	20d8 <read_key>
      if (is_pressed(k, 2)) {
    24d0:	1080010c 	andi	r2,r2,4
        wait_release(2);
        return 0; // Lockout cancelled
      }
      usleep(POLL_US);
    24d4:	0104e204 	movi	r4,5000
    int ones = t % 10;
    hex_write(pack4(0, 0, (uint8_t)tens, (uint8_t)ones));

    // Check KEY2 during each second
    int slice;
    for ( slice = 0; slice < 200; slice++) {
    24d8:	84000044 	addi	r16,r16,1
      uint32_t k = read_key();
      if (is_pressed(k, 2)) {
    24dc:	103fe426 	beq	r2,zero,2470 <main+0x284>
        wait_release(2);
        return 0; // Lockout cancelled
      }
      usleep(POLL_US);
    24e0:	00027880 	call	2788 <usleep>
    int ones = t % 10;
    hex_write(pack4(0, 0, (uint8_t)tens, (uint8_t)ones));

    // Check KEY2 during each second
    int slice;
    for ( slice = 0; slice < 200; slice++) {
    24e4:	00803204 	movi	r2,200
    24e8:	80bff81e 	bne	r16,r2,24cc <main+0x2e0>

// ---------- LOCKOUT HANDLER ----------
// Returns: 1 if lockout completed normally, 0 if KEY2 pressed (cancelled)
static int handle_lockout(void) {
  int t;
  for (t = LOCKOUT_SECONDS; t >= 0; t--) {
    24ec:	8c7fffc4 	addi	r17,r17,-1
    24f0:	00bfffc4 	movi	r2,-1
    24f4:	88bfe31e 	bne	r17,r2,2484 <main+0x298>
            handle_lockout();

            // After lockout (cancelled or completed)
            state = STATE_IDLE;
            wrong_streak = 0;
            leds_off();
    24f8:	00021d80 	call	21d8 <leds_off>
            hex_write(pack4(0,0,0,0));
    24fc:	0009883a 	mov	r4,zero
    2500:	000b883a 	mov	r5,zero
    2504:	000d883a 	mov	r6,zero
    2508:	000f883a 	mov	r7,zero
    250c:	000205c0 	call	205c <pack4>
    2510:	1009883a 	mov	r4,r2
    2514:	000212c0 	call	212c <hex_write>
    2518:	002b883a 	mov	r21,zero
    251c:	0027883a 	mov	r19,zero
    2520:	003f5106 	br	2268 <main+0x7c>
      } else {
        // VERIFY PASSWORD
        if (codes_match(entry, code)) {
          wrong_streak = 0;
          state = STATE_IDLE;
          leds_ok();
    2524:	00021c00 	call	21c0 <leds_ok>
          clear_entry(entry, &idx);
    2528:	d9000044 	addi	r4,sp,1
    252c:	d80b883a 	mov	r5,sp
    2530:	00021680 	call	2168 <clear_entry>
    2534:	003ff806 	br	2518 <main+0x32c>

00002538 <udivmodsi4>:
    2538:	29001b2e 	bgeu	r5,r4,25a8 <udivmodsi4+0x70>
    253c:	28001a16 	blt	r5,zero,25a8 <udivmodsi4+0x70>
    2540:	00800044 	movi	r2,1
    2544:	0007883a 	mov	r3,zero
    2548:	01c007c4 	movi	r7,31
    254c:	00000306 	br	255c <udivmodsi4+0x24>
    2550:	19c01326 	beq	r3,r7,25a0 <udivmodsi4+0x68>
    2554:	18c00044 	addi	r3,r3,1
    2558:	28000416 	blt	r5,zero,256c <udivmodsi4+0x34>
    255c:	294b883a 	add	r5,r5,r5
    2560:	1085883a 	add	r2,r2,r2
    2564:	293ffa36 	bltu	r5,r4,2550 <udivmodsi4+0x18>
    2568:	10000d26 	beq	r2,zero,25a0 <udivmodsi4+0x68>
    256c:	0007883a 	mov	r3,zero
    2570:	21400236 	bltu	r4,r5,257c <udivmodsi4+0x44>
    2574:	2149c83a 	sub	r4,r4,r5
    2578:	1886b03a 	or	r3,r3,r2
    257c:	1004d07a 	srli	r2,r2,1
    2580:	280ad07a 	srli	r5,r5,1
    2584:	103ffa1e 	bne	r2,zero,2570 <udivmodsi4+0x38>
    2588:	30000226 	beq	r6,zero,2594 <udivmodsi4+0x5c>
    258c:	2005883a 	mov	r2,r4
    2590:	f800283a 	ret
    2594:	1809883a 	mov	r4,r3
    2598:	2005883a 	mov	r2,r4
    259c:	f800283a 	ret
    25a0:	0007883a 	mov	r3,zero
    25a4:	003ff806 	br	2588 <udivmodsi4+0x50>
    25a8:	00800044 	movi	r2,1
    25ac:	0007883a 	mov	r3,zero
    25b0:	003fef06 	br	2570 <udivmodsi4+0x38>

000025b4 <__divsi3>:
    25b4:	defffe04 	addi	sp,sp,-8
    25b8:	dc000015 	stw	r16,0(sp)
    25bc:	dfc00115 	stw	ra,4(sp)
    25c0:	0021883a 	mov	r16,zero
    25c4:	20000c16 	blt	r4,zero,25f8 <__divsi3+0x44>
    25c8:	000d883a 	mov	r6,zero
    25cc:	28000e16 	blt	r5,zero,2608 <__divsi3+0x54>
    25d0:	00025380 	call	2538 <udivmodsi4>
    25d4:	1007883a 	mov	r3,r2
    25d8:	8005003a 	cmpeq	r2,r16,zero
    25dc:	1000011e 	bne	r2,zero,25e4 <__divsi3+0x30>
    25e0:	00c7c83a 	sub	r3,zero,r3
    25e4:	1805883a 	mov	r2,r3
    25e8:	dfc00117 	ldw	ra,4(sp)
    25ec:	dc000017 	ldw	r16,0(sp)
    25f0:	dec00204 	addi	sp,sp,8
    25f4:	f800283a 	ret
    25f8:	0109c83a 	sub	r4,zero,r4
    25fc:	04000044 	movi	r16,1
    2600:	000d883a 	mov	r6,zero
    2604:	283ff20e 	bge	r5,zero,25d0 <__divsi3+0x1c>
    2608:	014bc83a 	sub	r5,zero,r5
    260c:	8021003a 	cmpeq	r16,r16,zero
    2610:	003fef06 	br	25d0 <__divsi3+0x1c>

00002614 <__modsi3>:
    2614:	deffff04 	addi	sp,sp,-4
    2618:	dfc00015 	stw	ra,0(sp)
    261c:	01800044 	movi	r6,1
    2620:	2807883a 	mov	r3,r5
    2624:	20000416 	blt	r4,zero,2638 <__modsi3+0x24>
    2628:	28000c16 	blt	r5,zero,265c <__modsi3+0x48>
    262c:	dfc00017 	ldw	ra,0(sp)
    2630:	dec00104 	addi	sp,sp,4
    2634:	00025381 	jmpi	2538 <udivmodsi4>
    2638:	0109c83a 	sub	r4,zero,r4
    263c:	28000b16 	blt	r5,zero,266c <__modsi3+0x58>
    2640:	180b883a 	mov	r5,r3
    2644:	01800044 	movi	r6,1
    2648:	00025380 	call	2538 <udivmodsi4>
    264c:	0085c83a 	sub	r2,zero,r2
    2650:	dfc00017 	ldw	ra,0(sp)
    2654:	dec00104 	addi	sp,sp,4
    2658:	f800283a 	ret
    265c:	014bc83a 	sub	r5,zero,r5
    2660:	dfc00017 	ldw	ra,0(sp)
    2664:	dec00104 	addi	sp,sp,4
    2668:	00025381 	jmpi	2538 <udivmodsi4>
    266c:	0147c83a 	sub	r3,zero,r5
    2670:	003ff306 	br	2640 <__modsi3+0x2c>

00002674 <__udivsi3>:
    2674:	000d883a 	mov	r6,zero
    2678:	00025381 	jmpi	2538 <udivmodsi4>

0000267c <__umodsi3>:
    267c:	01800044 	movi	r6,1
    2680:	00025381 	jmpi	2538 <udivmodsi4>

00002684 <memcpy>:
    2684:	2011883a 	mov	r8,r4
    2688:	30000726 	beq	r6,zero,26a8 <memcpy+0x24>
    268c:	000f883a 	mov	r7,zero
    2690:	29c5883a 	add	r2,r5,r7
    2694:	11000003 	ldbu	r4,0(r2)
    2698:	41c7883a 	add	r3,r8,r7
    269c:	39c00044 	addi	r7,r7,1
    26a0:	19000005 	stb	r4,0(r3)
    26a4:	39bffa1e 	bne	r7,r6,2690 <memcpy+0xc>
    26a8:	4005883a 	mov	r2,r8
    26ac:	f800283a 	ret

000026b0 <memset>:
    26b0:	30000526 	beq	r6,zero,26c8 <memset+0x18>
    26b4:	310d883a 	add	r6,r6,r4
    26b8:	2005883a 	mov	r2,r4
    26bc:	11400005 	stb	r5,0(r2)
    26c0:	10800044 	addi	r2,r2,1
    26c4:	11bffd1e 	bne	r2,r6,26bc <memset+0xc>
    26c8:	2005883a 	mov	r2,r4
    26cc:	f800283a 	ret

000026d0 <alt_load_section>:

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    26d0:	2900051e 	bne	r5,r4,26e8 <alt_load_section+0x18>
    26d4:	f800283a 	ret
  {
    while( to != end )
    {
      *to++ = *from++;
    26d8:	20800017 	ldw	r2,0(r4)
    26dc:	21000104 	addi	r4,r4,4
    26e0:	28800015 	stw	r2,0(r5)
    26e4:	29400104 	addi	r5,r5,4
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
    26e8:	29bffb1e 	bne	r5,r6,26d8 <alt_load_section+0x8>
    26ec:	f800283a 	ret

000026f0 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    26f0:	deffff04 	addi	sp,sp,-4
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
    26f4:	01000034 	movhi	r4,0
    26f8:	210a2704 	addi	r4,r4,10396
    26fc:	01400034 	movhi	r5,0
    2700:	294a2504 	addi	r5,r5,10388
    2704:	01800034 	movhi	r6,0
    2708:	318a2704 	addi	r6,r6,10396
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    270c:	dfc00015 	stw	ra,0(sp)
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
    2710:	00026d00 	call	26d0 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
    2714:	01000034 	movhi	r4,0
    2718:	21080804 	addi	r4,r4,8224
    271c:	01400034 	movhi	r5,0
    2720:	29480804 	addi	r5,r5,8224
    2724:	01800034 	movhi	r6,0
    2728:	31880804 	addi	r6,r6,8224
    272c:	00026d00 	call	26d0 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
    2730:	01000034 	movhi	r4,0
    2734:	210a2104 	addi	r4,r4,10372
    2738:	01400034 	movhi	r5,0
    273c:	294a2104 	addi	r5,r5,10372
    2740:	01800034 	movhi	r6,0
    2744:	318a2504 	addi	r6,r6,10388
    2748:	00026d00 	call	26d0 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    274c:	000283c0 	call	283c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    2750:	dfc00017 	ldw	ra,0(sp)
    2754:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    2758:	00028401 	jmpi	2840 <alt_icache_flush_all>

0000275c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    275c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2760:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2764:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2768:	00027900 	call	2790 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    276c:	000278c0 	call	278c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2770:	d1200517 	ldw	r4,-32748(gp)
    2774:	d1600617 	ldw	r5,-32744(gp)
    2778:	d1a00717 	ldw	r6,-32740(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    277c:	dfc00017 	ldw	ra,0(sp)
    2780:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2784:	00021ec1 	jmpi	21ec <main>

00002788 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
    2788:	00027b01 	jmpi	27b0 <alt_busy_sleep>

0000278c <alt_sys_init>:
void alt_sys_init( void )
{
    ALTERA_AVALON_TIMER_INIT ( TIMER, TIMER);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, JTAG_UART);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
}
    278c:	f800283a 	ret

00002790 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    2790:	deffff04 	addi	sp,sp,-4
    2794:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, CPU);
    2798:	00028440 	call	2844 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    279c:	00800044 	movi	r2,1
    27a0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    27a4:	dfc00017 	ldw	ra,0(sp)
    27a8:	dec00104 	addi	sp,sp,4
    27ac:	f800283a 	ret

000027b0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    27b0:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    27b4:	014666b4 	movhi	r5,6554
    27b8:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
    27bc:	dc000015 	stw	r16,0(sp)
    27c0:	dfc00115 	stw	ra,4(sp)
    27c4:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
    27c8:	00026740 	call	2674 <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
    27cc:	10001126 	beq	r2,zero,2814 <alt_busy_sleep+0x64>
    27d0:	0007883a 	mov	r3,zero
    27d4:	01200034 	movhi	r4,32768
    27d8:	213fffc4 	addi	r4,r4,-1
    27dc:	017999b4 	movhi	r5,58982
    27e0:	295999c4 	addi	r5,r5,26215
    27e4:	00000406 	br	27f8 <alt_busy_sleep+0x48>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
    27e8:	213fffc4 	addi	r4,r4,-1
    27ec:	203ffe1e 	bne	r4,zero,27e8 <alt_busy_sleep+0x38>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
    27f0:	8161883a 	add	r16,r16,r5
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
    27f4:	18c00044 	addi	r3,r3,1
    27f8:	18bffb16 	blt	r3,r2,27e8 <alt_busy_sleep+0x38>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    27fc:	8009883a 	mov	r4,r16
    2800:	01400144 	movi	r5,5
    2804:	000284c0 	call	284c <__mulsi3>
    2808:	10bfffc4 	addi	r2,r2,-1
    280c:	103ffe1e 	bne	r2,zero,2808 <alt_busy_sleep+0x58>
    2810:	00000506 	br	2828 <alt_busy_sleep+0x78>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
    2814:	8009883a 	mov	r4,r16
    2818:	01400144 	movi	r5,5
    281c:	000284c0 	call	284c <__mulsi3>
    2820:	10bfffc4 	addi	r2,r2,-1
    2824:	00bffe16 	blt	zero,r2,2820 <alt_busy_sleep+0x70>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
    2828:	0005883a 	mov	r2,zero
    282c:	dfc00117 	ldw	ra,4(sp)
    2830:	dc000017 	ldw	r16,0(sp)
    2834:	dec00204 	addi	sp,sp,8
    2838:	f800283a 	ret

0000283c <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
    283c:	f800283a 	ret

00002840 <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
    2840:	f800283a 	ret

00002844 <altera_nios2_qsys_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    2844:	000170fa 	wrctl	ienable,zero
}
    2848:	f800283a 	ret

0000284c <__mulsi3>:
    284c:	20000a26 	beq	r4,zero,2878 <__mulsi3+0x2c>
    2850:	0007883a 	mov	r3,zero
    2854:	2080004c 	andi	r2,r4,1
    2858:	1005003a 	cmpeq	r2,r2,zero
    285c:	2008d07a 	srli	r4,r4,1
    2860:	1000011e 	bne	r2,zero,2868 <__mulsi3+0x1c>
    2864:	1947883a 	add	r3,r3,r5
    2868:	294b883a 	add	r5,r5,r5
    286c:	203ff91e 	bne	r4,zero,2854 <__mulsi3+0x8>
    2870:	1805883a 	mov	r2,r3
    2874:	f800283a 	ret
    2878:	0007883a 	mov	r3,zero
    287c:	1805883a 	mov	r2,r3
    2880:	f800283a 	ret
