/* 
 * "Small Hello World" example. 
 * 
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example 
 * designs. It requires a STDOUT  device in your system's hardware. 
 *
 * The purpose of this example is to demonstrate the smallest possible Hello 
 * World application, using the Nios II HAL library.  The memory footprint
 * of this hosted application is ~332 bytes by default using the standard
 * reference design.  For a more fully featured Hello World application
 * example, see the example titled "Hello World".
 *
 * The memory footprint of this example has been reduced by making the
 * following changes to the normal "Hello World" example.
 * Check in the Nios II Software Developers Manual for a more complete
 * description.
 *
 * In the SW Application project (small_hello_world):
 *
 *  - In the C/C++ Build page
 *
 *    - Set the Optimization Level to -Os
 *
 * In System Library project (small_hello_world_syslib):
 *  - In the C/C++ Build page
 *
 *    - Set the Optimization Level to -Os
 *
 *    - Define the preprocessor option ALT_NO_INSTRUCTION_EMULATION
 *      This removes software exception handling, which means that you cannot
 *      run code compiled for Nios II cpu with a hardware multiplier on a core
 *      without a the multiply unit. Check the Nios II Software Developers
 *      Manual for more details.
 *
 *  - In the System Library page:
 *    - Set Periodic system timer and Timestamp timer to none
 *      This prevents the automatic inclusion of the timer driver.
 *
 *    - Set Max file descriptors to 4
 *      This reduces the size of the file handle pool.
 *
 *    - Check Main function does not exit
 *    - Uncheck Clean exit (flush buffers)
 *      This removes the unneeded call to exit when main returns, since it
 *      won't.
 *
 *    - Check Don't use C++
 *      This builds without the C++ support code.
 *
 *    - Check Small C library
 *      This uses a reduced functionality C library, which lacks
 *      support for buffering, file IO, floating point and getch(), etc.
 *      Check the Nios II Software Developers Manual for a complete list.
 *
 *    - Check Reduced device drivers
 *      This uses reduced functionality drivers if they're available. For the
 *      standard design this means you get polled UART and JTAG UART drivers,
 *      no support for the LCD driver and you lose the ability to program
 *      CFI compliant flash devices.
 *
 *    - Check Access device drivers directly
 *      This bypasses the device file system to access device drivers directly.
 *      This eliminates the space required for the device file system services.
 *      It also provides a HAL version of libc services that access the drivers
 *      directly, further reducing space. Only a limited number of libc
 *      functions are available in this configuration.
 *
 *    - Use ALT versions of stdio routines:
 *
 *           Function                  Description
 *        ===============  =====================================
 *        alt_printf       Only supports %s, %x, and %c ( < 1 Kbyte)
 *        alt_putstr       Smaller overhead than puts with direct drivers
 *                         Note this function doesn't add a newline.
 *        alt_putchar      Smaller overhead than putchar with direct drivers
 *        alt_getchar      Smaller overhead than getchar with direct drivers
 *
 */

#include "sys/alt_stdio.h"

#include <stdint.h>
#include <unistd.h>
#include "system.h"
#include "io.h"



/*
DIGITAL LOCK - IMPROVED VERSION
Fixes:
- Lockout bypass bug (KEY2 during countdown now properly cancels)
- Change mode visual feedback (blinks HEX displays)
- Clearer state machine with enum
- Better digit entry validation
- Improved code organization
*/

// ---------- CONFIG ----------
#define CODE_LEN          4
#define LOCKOUT_SECONDS  10
#define POLL_US          5000   // 5ms polling
#define AFTER_RELEASE_US 20000  // 20ms debounce after release
#define BLINK_CYCLES     100    // 500ms blink period (100 * 5ms)

// ---------- STATE MACHINE ----------
typedef enum {
  STATE_IDLE,
  STATE_ENTERING,
  STATE_CHANGE_MODE,
  STATE_LOCKED
} state_t;

// ---------- 7-Seg LUT (active-low) ----------
static const uint8_t seg7[16] = {
  0x40, 0x79, 0x24, 0x30, 0x19, 0x12, 0x02, 0x78,
  0x00, 0x10, 0x08, 0x03, 0x46, 0x21, 0x06, 0x0E
};

// ---------- HW ACCESS ----------
static inline uint32_t read_key(void) { return IORD(KEY_BASE, 0) & 0xF; }
static inline uint32_t read_sw(void)  { return IORD(SW_BASE,  0) & 0x3FF; }

static inline void leds_off(void) {
  IOWR(LEDR_BASE, 0, 0);
  IOWR(LEDG_BASE, 0, 0);
}
static inline void leds_ok(void) {
  IOWR(LEDR_BASE, 0, 0);
  IOWR(LEDG_BASE, 0, 1);
}
static inline void leds_err(void) {
  IOWR(LEDG_BASE, 0, 0);
  IOWR(LEDR_BASE, 0, 1);
}
static inline void hex_write(uint32_t v) {
  IOWR(HEX_BASE, 0, v);
}

static uint32_t pack4(uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3) {
  uint32_t h0 = seg7[d0 & 0xF];
  uint32_t h1 = seg7[d1 & 0xF];
  uint32_t h2 = seg7[d2 & 0xF];
  uint32_t h3 = seg7[d3 & 0xF];
  return (h0) | (h1 << 7) | (h2 << 14) | (h3 << 21);
}

// ---------- DEBOUNCE ----------
static inline int is_pressed(uint32_t k, int bit) {
  return ((k & (1u << bit)) == 0);
}

static void wait_release(int bit) {
  while (is_pressed(read_key(), bit)) {
    usleep(POLL_US);
  }
  usleep(AFTER_RELEASE_US);
}

static int press_event(uint32_t prev, uint32_t now, int bit) {
  int was_released = ((prev & (1u << bit)) != 0);
  int now_pressed  = ((now  & (1u << bit)) == 0);
  return (was_released && now_pressed);
}

// ---------- HELPERS ----------
static void clear_entry(uint8_t entry[CODE_LEN], uint8_t *idx) {
  for (int i = 0; i < CODE_LEN; i++) entry[i] = 0;
  *idx = 0;
  hex_write(pack4(0,0,0,0));
}

static void show_entry(const uint8_t entry[CODE_LEN]) {
  hex_write(pack4(entry[0], entry[1], entry[2], entry[3]));
}

static int codes_match(const uint8_t a[CODE_LEN], const uint8_t b[CODE_LEN]) {
  for (int i = 0; i < CODE_LEN; i++) {
    if (a[i] != b[i]) return 0;
  }
  return 1;
}

// ---------- LOCKOUT HANDLER ----------
// Returns: 1 if lockout completed normally, 0 if KEY2 pressed (cancelled)
static int handle_lockout(void) {
  for (int t = LOCKOUT_SECONDS; t >= 0; t--) {
    int tens = (t / 10) % 10;
    int ones = t % 10;
    hex_write(pack4(0, 0, (uint8_t)tens, (uint8_t)ones));

    // Check KEY2 during each second
    for (int slice = 0; slice < 200; slice++) {
      uint32_t k = read_key();
      if (is_pressed(k, 2)) {
        wait_release(2);
        return 0; // Lockout cancelled
      }
      usleep(POLL_US);
    }
  }
  return 1; // Lockout completed
}

// ---------- MAIN ----------
int main(void) {
  uint8_t code[CODE_LEN]  = {1,2,3,4};  // Default password
  uint8_t entry[CODE_LEN] = {0,0,0,0};
  uint8_t idx = 0;
  uint8_t wrong_streak = 0;
  state_t state = STATE_IDLE;
  uint16_t blink_counter = 0;

  leds_off();
  hex_write(pack4(0,0,0,0));

  uint32_t prev_k = read_key();

  while (1) {
    uint32_t k = read_key();

    // ---------- HANDLE CHANGE MODE BLINKING ----------
    if (state == STATE_CHANGE_MODE) {
      blink_counter++;
      if (blink_counter >= BLINK_CYCLES) {
        blink_counter = 0;
        // Toggle display: show entry or blank
        static uint8_t blink_state = 0;
        blink_state = !blink_state;
        if (blink_state) {
          show_entry(entry);
        } else {
          hex_write(0x7F7F7F7F); // All segments off (blank)
        }
      }
    }

    // ---------- KEY2: RESET (works in any state) ----------
    if (press_event(prev_k, k, 2)) {
      wait_release(2);

      state = STATE_IDLE;
      wrong_streak = 0;
      clear_entry(entry, &idx);
      leds_off();
      blink_counter = 0;
    }

    // ---------- LOCKED STATE: Only countdown, ignore other keys ----------
    if (state == STATE_LOCKED) {
      prev_k = k;
      usleep(POLL_US);
      continue;
    }

    // ---------- KEY3: ENTER CHANGE MODE ----------
    if (press_event(prev_k, k, 3)) {
      wait_release(3);

      state = STATE_CHANGE_MODE;
      wrong_streak = 0;
      clear_entry(entry, &idx);
      leds_off();
      blink_counter = 0;
    }

    // ---------- KEY0: ENTER DIGIT ----------
    if (press_event(prev_k, k, 0)) {
      wait_release(0);

      uint8_t digit = (uint8_t)(read_sw() & 0xF);
      if (digit > 9) digit = 9;

      if (idx < CODE_LEN) {
        entry[idx] = digit;
        idx++;
        show_entry(entry);
        leds_off();

        // Update state
        if (state == STATE_IDLE) {
          state = STATE_ENTERING;
        }
        blink_counter = 0; // Reset blink if in change mode
      }
    }

    // ---------- KEY1: VERIFY OR SAVE ----------
    if (press_event(prev_k, k, 1)) {
      wait_release(1);

      // Require full 4 digits
      if (idx < CODE_LEN) {
        // Not enough digits - blink error briefly
        leds_err();
        usleep(200000); // 200ms error indication
        leds_off();
        prev_k = k;
        usleep(POLL_US);
        continue;
      }

      if (state == STATE_CHANGE_MODE) {
        // SAVE NEW PASSWORD
        for (int i = 0; i < CODE_LEN; i++) {
          code[i] = entry[i];
        }
        state = STATE_IDLE;
        wrong_streak = 0;
        leds_ok();
        clear_entry(entry, &idx);

      } else {
        // VERIFY PASSWORD
        if (codes_match(entry, code)) {
          wrong_streak = 0;
          state = STATE_IDLE;
          leds_ok();
          clear_entry(entry, &idx);

        } else {
          wrong_streak++;
          leds_err();
          clear_entry(entry, &idx);
          state = STATE_IDLE;

          if (wrong_streak >= 3) {
            // TRIGGER LOCKOUT
            state = STATE_LOCKED;
            leds_off();

            int completed = handle_lockout();

            // After lockout (cancelled or completed)
            state = STATE_IDLE;
            wrong_streak = 0;
            leds_off();
            hex_write(pack4(0,0,0,0));
          }
        }
      }
    }

    prev_k = k;
    usleep(POLL_US);
  }

  return 0;
}
